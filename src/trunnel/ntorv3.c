/* ntorv3.c -- generated by Trunnel v1.5.3.
 * https://gitweb.torproject.org/trunnel.git
 * You probably shouldn't edit this file.
 */
#include <stdlib.h>
#include "trunnel-impl.h"

#include "ntorv3.h"

#define TRUNNEL_SET_ERROR_CODE(obj) \
  do {                              \
    (obj)->trunnel_error_code_ = 1; \
  } while (0)

#if defined(__COVERITY__) || defined(__clang_analyzer__)
/* If we're running a static analysis tool, we don't want it to complain
 * that some of our remaining-bytes checks are dead-code. */
int ntorv_deadcode_dummy__ = 0;
#define OR_DEADCODE_DUMMY || ntorv_deadcode_dummy__
#else
#define OR_DEADCODE_DUMMY
#endif

#define CHECK_REMAINING(nbytes, label)                           \
  do {                                                           \
    if (remaining < (nbytes) OR_DEADCODE_DUMMY) {                \
      goto label;                                                \
    }                                                            \
  } while (0)

trn_ntorv3_ext_cc_response_t *
trn_ntorv3_ext_cc_response_new(void)
{
  trn_ntorv3_ext_cc_response_t *val = trunnel_calloc(1, sizeof(trn_ntorv3_ext_cc_response_t));
  if (NULL == val)
    return NULL;
  return val;
}

/** Release all storage held inside 'obj', but do not free 'obj'.
 */
static void
trn_ntorv3_ext_cc_response_clear(trn_ntorv3_ext_cc_response_t *obj)
{
  (void) obj;
}

void
trn_ntorv3_ext_cc_response_free(trn_ntorv3_ext_cc_response_t *obj)
{
  if (obj == NULL)
    return;
  trn_ntorv3_ext_cc_response_clear(obj);
  trunnel_memwipe(obj, sizeof(trn_ntorv3_ext_cc_response_t));
  trunnel_free_(obj);
}

uint8_t
trn_ntorv3_ext_cc_response_get_sendme_inc(const trn_ntorv3_ext_cc_response_t *inp)
{
  return inp->sendme_inc;
}
int
trn_ntorv3_ext_cc_response_set_sendme_inc(trn_ntorv3_ext_cc_response_t *inp, uint8_t val)
{
  inp->sendme_inc = val;
  return 0;
}
const char *
trn_ntorv3_ext_cc_response_check(const trn_ntorv3_ext_cc_response_t *obj)
{
  if (obj == NULL)
    return "Object was NULL";
  if (obj->trunnel_error_code_)
    return "A set function failed on this object";
  return NULL;
}

ssize_t
trn_ntorv3_ext_cc_response_encoded_len(const trn_ntorv3_ext_cc_response_t *obj)
{
  ssize_t result = 0;

  if (NULL != trn_ntorv3_ext_cc_response_check(obj))
     return -1;


  /* Length of u8 sendme_inc */
  result += 1;
  return result;
}
int
trn_ntorv3_ext_cc_response_clear_errors(trn_ntorv3_ext_cc_response_t *obj)
{
  int r = obj->trunnel_error_code_;
  obj->trunnel_error_code_ = 0;
  return r;
}
ssize_t
trn_ntorv3_ext_cc_response_encode(uint8_t *output, const size_t avail, const trn_ntorv3_ext_cc_response_t *obj)
{
  ssize_t result = 0;
  size_t written = 0;
  uint8_t *ptr = output;
  const char *msg;
#ifdef TRUNNEL_CHECK_ENCODED_LEN
  const ssize_t encoded_len = trn_ntorv3_ext_cc_response_encoded_len(obj);
#endif

  if (NULL != (msg = trn_ntorv3_ext_cc_response_check(obj)))
    goto check_failed;

#ifdef TRUNNEL_CHECK_ENCODED_LEN
  trunnel_assert(encoded_len >= 0);
#endif

  /* Encode u8 sendme_inc */
  trunnel_assert(written <= avail);
  if (avail - written < 1)
    goto truncated;
  trunnel_set_uint8(ptr, (obj->sendme_inc));
  written += 1; ptr += 1;


  trunnel_assert(ptr == output + written);
#ifdef TRUNNEL_CHECK_ENCODED_LEN
  {
    trunnel_assert(encoded_len >= 0);
    trunnel_assert((size_t)encoded_len == written);
  }

#endif

  return written;

 truncated:
  result = -2;
  goto fail;
 check_failed:
  (void)msg;
  result = -1;
  goto fail;
 fail:
  trunnel_assert(result < 0);
  return result;
}

/** As trn_ntorv3_ext_cc_response_parse(), but do not allocate the
 * output object.
 */
static ssize_t
trn_ntorv3_ext_cc_response_parse_into(trn_ntorv3_ext_cc_response_t *obj, const uint8_t *input, const size_t len_in)
{
  const uint8_t *ptr = input;
  size_t remaining = len_in;
  ssize_t result = 0;
  (void)result;

  /* Parse u8 sendme_inc */
  CHECK_REMAINING(1, truncated);
  obj->sendme_inc = (trunnel_get_uint8(ptr));
  remaining -= 1; ptr += 1;
  trunnel_assert(ptr + remaining == input + len_in);
  return len_in - remaining;

 truncated:
  return -2;
}

ssize_t
trn_ntorv3_ext_cc_response_parse(trn_ntorv3_ext_cc_response_t **output, const uint8_t *input, const size_t len_in)
{
  ssize_t result;
  *output = trn_ntorv3_ext_cc_response_new();
  if (NULL == *output)
    return -1;
  result = trn_ntorv3_ext_cc_response_parse_into(*output, input, len_in);
  if (result < 0) {
    trn_ntorv3_ext_cc_response_free(*output);
    *output = NULL;
  }
  return result;
}
trn_ntorv3_ext_subproto_req_t *
trn_ntorv3_ext_subproto_req_new(void)
{
  trn_ntorv3_ext_subproto_req_t *val = trunnel_calloc(1, sizeof(trn_ntorv3_ext_subproto_req_t));
  if (NULL == val)
    return NULL;
  return val;
}

/** Release all storage held inside 'obj', but do not free 'obj'.
 */
static void
trn_ntorv3_ext_subproto_req_clear(trn_ntorv3_ext_subproto_req_t *obj)
{
  (void) obj;
}

void
trn_ntorv3_ext_subproto_req_free(trn_ntorv3_ext_subproto_req_t *obj)
{
  if (obj == NULL)
    return;
  trn_ntorv3_ext_subproto_req_clear(obj);
  trunnel_memwipe(obj, sizeof(trn_ntorv3_ext_subproto_req_t));
  trunnel_free_(obj);
}

uint8_t
trn_ntorv3_ext_subproto_req_get_proto_id(const trn_ntorv3_ext_subproto_req_t *inp)
{
  return inp->proto_id;
}
int
trn_ntorv3_ext_subproto_req_set_proto_id(trn_ntorv3_ext_subproto_req_t *inp, uint8_t val)
{
  inp->proto_id = val;
  return 0;
}
uint8_t
trn_ntorv3_ext_subproto_req_get_proto_version(const trn_ntorv3_ext_subproto_req_t *inp)
{
  return inp->proto_version;
}
int
trn_ntorv3_ext_subproto_req_set_proto_version(trn_ntorv3_ext_subproto_req_t *inp, uint8_t val)
{
  inp->proto_version = val;
  return 0;
}
const char *
trn_ntorv3_ext_subproto_req_check(const trn_ntorv3_ext_subproto_req_t *obj)
{
  if (obj == NULL)
    return "Object was NULL";
  if (obj->trunnel_error_code_)
    return "A set function failed on this object";
  return NULL;
}

ssize_t
trn_ntorv3_ext_subproto_req_encoded_len(const trn_ntorv3_ext_subproto_req_t *obj)
{
  ssize_t result = 0;

  if (NULL != trn_ntorv3_ext_subproto_req_check(obj))
     return -1;


  /* Length of u8 proto_id */
  result += 1;

  /* Length of u8 proto_version */
  result += 1;
  return result;
}
int
trn_ntorv3_ext_subproto_req_clear_errors(trn_ntorv3_ext_subproto_req_t *obj)
{
  int r = obj->trunnel_error_code_;
  obj->trunnel_error_code_ = 0;
  return r;
}
ssize_t
trn_ntorv3_ext_subproto_req_encode(uint8_t *output, const size_t avail, const trn_ntorv3_ext_subproto_req_t *obj)
{
  ssize_t result = 0;
  size_t written = 0;
  uint8_t *ptr = output;
  const char *msg;
#ifdef TRUNNEL_CHECK_ENCODED_LEN
  const ssize_t encoded_len = trn_ntorv3_ext_subproto_req_encoded_len(obj);
#endif

  if (NULL != (msg = trn_ntorv3_ext_subproto_req_check(obj)))
    goto check_failed;

#ifdef TRUNNEL_CHECK_ENCODED_LEN
  trunnel_assert(encoded_len >= 0);
#endif

  /* Encode u8 proto_id */
  trunnel_assert(written <= avail);
  if (avail - written < 1)
    goto truncated;
  trunnel_set_uint8(ptr, (obj->proto_id));
  written += 1; ptr += 1;

  /* Encode u8 proto_version */
  trunnel_assert(written <= avail);
  if (avail - written < 1)
    goto truncated;
  trunnel_set_uint8(ptr, (obj->proto_version));
  written += 1; ptr += 1;


  trunnel_assert(ptr == output + written);
#ifdef TRUNNEL_CHECK_ENCODED_LEN
  {
    trunnel_assert(encoded_len >= 0);
    trunnel_assert((size_t)encoded_len == written);
  }

#endif

  return written;

 truncated:
  result = -2;
  goto fail;
 check_failed:
  (void)msg;
  result = -1;
  goto fail;
 fail:
  trunnel_assert(result < 0);
  return result;
}

/** As trn_ntorv3_ext_subproto_req_parse(), but do not allocate the
 * output object.
 */
static ssize_t
trn_ntorv3_ext_subproto_req_parse_into(trn_ntorv3_ext_subproto_req_t *obj, const uint8_t *input, const size_t len_in)
{
  const uint8_t *ptr = input;
  size_t remaining = len_in;
  ssize_t result = 0;
  (void)result;

  /* Parse u8 proto_id */
  CHECK_REMAINING(1, truncated);
  obj->proto_id = (trunnel_get_uint8(ptr));
  remaining -= 1; ptr += 1;

  /* Parse u8 proto_version */
  CHECK_REMAINING(1, truncated);
  obj->proto_version = (trunnel_get_uint8(ptr));
  remaining -= 1; ptr += 1;
  trunnel_assert(ptr + remaining == input + len_in);
  return len_in - remaining;

 truncated:
  return -2;
}

ssize_t
trn_ntorv3_ext_subproto_req_parse(trn_ntorv3_ext_subproto_req_t **output, const uint8_t *input, const size_t len_in)
{
  ssize_t result;
  *output = trn_ntorv3_ext_subproto_req_new();
  if (NULL == *output)
    return -1;
  result = trn_ntorv3_ext_subproto_req_parse_into(*output, input, len_in);
  if (result < 0) {
    trn_ntorv3_ext_subproto_req_free(*output);
    *output = NULL;
  }
  return result;
}
trn_ntorv3_ext_subproto_t *
trn_ntorv3_ext_subproto_new(void)
{
  trn_ntorv3_ext_subproto_t *val = trunnel_calloc(1, sizeof(trn_ntorv3_ext_subproto_t));
  if (NULL == val)
    return NULL;
  return val;
}

/** Release all storage held inside 'obj', but do not free 'obj'.
 */
static void
trn_ntorv3_ext_subproto_clear(trn_ntorv3_ext_subproto_t *obj)
{
  (void) obj;
  {

    unsigned idx;
    for (idx = 0; idx < TRUNNEL_DYNARRAY_LEN(&obj->reqs); ++idx) {
      trn_ntorv3_ext_subproto_req_free(TRUNNEL_DYNARRAY_GET(&obj->reqs, idx));
    }
  }
  TRUNNEL_DYNARRAY_WIPE(&obj->reqs);
  TRUNNEL_DYNARRAY_CLEAR(&obj->reqs);
}

void
trn_ntorv3_ext_subproto_free(trn_ntorv3_ext_subproto_t *obj)
{
  if (obj == NULL)
    return;
  trn_ntorv3_ext_subproto_clear(obj);
  trunnel_memwipe(obj, sizeof(trn_ntorv3_ext_subproto_t));
  trunnel_free_(obj);
}

size_t
trn_ntorv3_ext_subproto_getlen_reqs(const trn_ntorv3_ext_subproto_t *inp)
{
  return TRUNNEL_DYNARRAY_LEN(&inp->reqs);
}

struct trn_ntorv3_ext_subproto_req_st *
trn_ntorv3_ext_subproto_get_reqs(trn_ntorv3_ext_subproto_t *inp, size_t idx)
{
  return TRUNNEL_DYNARRAY_GET(&inp->reqs, idx);
}

 const struct trn_ntorv3_ext_subproto_req_st *
trn_ntorv3_ext_subproto_getconst_reqs(const trn_ntorv3_ext_subproto_t *inp, size_t idx)
{
  return trn_ntorv3_ext_subproto_get_reqs((trn_ntorv3_ext_subproto_t*)inp, idx);
}
int
trn_ntorv3_ext_subproto_set_reqs(trn_ntorv3_ext_subproto_t *inp, size_t idx, struct trn_ntorv3_ext_subproto_req_st * elt)
{
  trn_ntorv3_ext_subproto_req_t *oldval = TRUNNEL_DYNARRAY_GET(&inp->reqs, idx);
  if (oldval && oldval != elt)
    trn_ntorv3_ext_subproto_req_free(oldval);
  return trn_ntorv3_ext_subproto_set0_reqs(inp, idx, elt);
}
int
trn_ntorv3_ext_subproto_set0_reqs(trn_ntorv3_ext_subproto_t *inp, size_t idx, struct trn_ntorv3_ext_subproto_req_st * elt)
{
  TRUNNEL_DYNARRAY_SET(&inp->reqs, idx, elt);
  return 0;
}
int
trn_ntorv3_ext_subproto_add_reqs(trn_ntorv3_ext_subproto_t *inp, struct trn_ntorv3_ext_subproto_req_st * elt)
{
  TRUNNEL_DYNARRAY_ADD(struct trn_ntorv3_ext_subproto_req_st *, &inp->reqs, elt, {});
  return 0;
 trunnel_alloc_failed:
  TRUNNEL_SET_ERROR_CODE(inp);
  return -1;
}

struct trn_ntorv3_ext_subproto_req_st * *
trn_ntorv3_ext_subproto_getarray_reqs(trn_ntorv3_ext_subproto_t *inp)
{
  return inp->reqs.elts_;
}
const struct trn_ntorv3_ext_subproto_req_st *  const  *
trn_ntorv3_ext_subproto_getconstarray_reqs(const trn_ntorv3_ext_subproto_t *inp)
{
  return (const struct trn_ntorv3_ext_subproto_req_st *  const  *)trn_ntorv3_ext_subproto_getarray_reqs((trn_ntorv3_ext_subproto_t*)inp);
}
int
trn_ntorv3_ext_subproto_setlen_reqs(trn_ntorv3_ext_subproto_t *inp, size_t newlen)
{
  struct trn_ntorv3_ext_subproto_req_st * *newptr;
  newptr = trunnel_dynarray_setlen(&inp->reqs.allocated_,
                 &inp->reqs.n_, inp->reqs.elts_, newlen,
                 sizeof(inp->reqs.elts_[0]), (trunnel_free_fn_t) trn_ntorv3_ext_subproto_req_free,
                 &inp->trunnel_error_code_);
  if (newlen != 0 && newptr == NULL)
    goto trunnel_alloc_failed;
  inp->reqs.elts_ = newptr;
  return 0;
 trunnel_alloc_failed:
  TRUNNEL_SET_ERROR_CODE(inp);
  return -1;
}
const char *
trn_ntorv3_ext_subproto_check(const trn_ntorv3_ext_subproto_t *obj)
{
  if (obj == NULL)
    return "Object was NULL";
  if (obj->trunnel_error_code_)
    return "A set function failed on this object";
  {
    const char *msg;

    unsigned idx;
    for (idx = 0; idx < TRUNNEL_DYNARRAY_LEN(&obj->reqs); ++idx) {
      if (NULL != (msg = trn_ntorv3_ext_subproto_req_check(TRUNNEL_DYNARRAY_GET(&obj->reqs, idx))))
        return msg;
    }
  }
  return NULL;
}

ssize_t
trn_ntorv3_ext_subproto_encoded_len(const trn_ntorv3_ext_subproto_t *obj)
{
  ssize_t result = 0;

  if (NULL != trn_ntorv3_ext_subproto_check(obj))
     return -1;


  /* Length of struct trn_ntorv3_ext_subproto_req reqs[] */
  {

    unsigned idx;
    for (idx = 0; idx < TRUNNEL_DYNARRAY_LEN(&obj->reqs); ++idx) {
      result += trn_ntorv3_ext_subproto_req_encoded_len(TRUNNEL_DYNARRAY_GET(&obj->reqs, idx));
    }
  }
  return result;
}
int
trn_ntorv3_ext_subproto_clear_errors(trn_ntorv3_ext_subproto_t *obj)
{
  int r = obj->trunnel_error_code_;
  obj->trunnel_error_code_ = 0;
  return r;
}
ssize_t
trn_ntorv3_ext_subproto_encode(uint8_t *output, const size_t avail, const trn_ntorv3_ext_subproto_t *obj)
{
  ssize_t result = 0;
  size_t written = 0;
  uint8_t *ptr = output;
  const char *msg;
#ifdef TRUNNEL_CHECK_ENCODED_LEN
  const ssize_t encoded_len = trn_ntorv3_ext_subproto_encoded_len(obj);
#endif

  if (NULL != (msg = trn_ntorv3_ext_subproto_check(obj)))
    goto check_failed;

#ifdef TRUNNEL_CHECK_ENCODED_LEN
  trunnel_assert(encoded_len >= 0);
#endif

  /* Encode struct trn_ntorv3_ext_subproto_req reqs[] */
  {

    unsigned idx;
    for (idx = 0; idx < TRUNNEL_DYNARRAY_LEN(&obj->reqs); ++idx) {
      trunnel_assert(written <= avail);
      result = trn_ntorv3_ext_subproto_req_encode(ptr, avail - written, TRUNNEL_DYNARRAY_GET(&obj->reqs, idx));
      if (result < 0)
        goto fail; /* XXXXXXX !*/
      written += result; ptr += result;
    }
  }


  trunnel_assert(ptr == output + written);
#ifdef TRUNNEL_CHECK_ENCODED_LEN
  {
    trunnel_assert(encoded_len >= 0);
    trunnel_assert((size_t)encoded_len == written);
  }

#endif

  return written;

 check_failed:
  (void)msg;
  result = -1;
  goto fail;
 fail:
  trunnel_assert(result < 0);
  return result;
}

/** As trn_ntorv3_ext_subproto_parse(), but do not allocate the output
 * object.
 */
static ssize_t
trn_ntorv3_ext_subproto_parse_into(trn_ntorv3_ext_subproto_t *obj, const uint8_t *input, const size_t len_in)
{
  const uint8_t *ptr = input;
  size_t remaining = len_in;
  ssize_t result = 0;
  (void)result;

  /* Parse struct trn_ntorv3_ext_subproto_req reqs[] */
  {
    trn_ntorv3_ext_subproto_req_t * elt;
    while (remaining > 0) {
      result = trn_ntorv3_ext_subproto_req_parse(&elt, ptr, remaining);
      if (result < 0)
        goto fail;
      trunnel_assert((size_t)result <= remaining);
      remaining -= result; ptr += result;
      TRUNNEL_DYNARRAY_ADD(trn_ntorv3_ext_subproto_req_t *, &obj->reqs, elt, {trn_ntorv3_ext_subproto_req_free(elt);});
    }
  }
  trunnel_assert(ptr + remaining == input + len_in);
  return len_in - remaining;

 trunnel_alloc_failed:
  return -1;
 fail:
  result = -1;
  return result;
}

ssize_t
trn_ntorv3_ext_subproto_parse(trn_ntorv3_ext_subproto_t **output, const uint8_t *input, const size_t len_in)
{
  ssize_t result;
  *output = trn_ntorv3_ext_subproto_new();
  if (NULL == *output)
    return -1;
  result = trn_ntorv3_ext_subproto_parse_into(*output, input, len_in);
  if (result < 0) {
    trn_ntorv3_ext_subproto_free(*output);
    *output = NULL;
  }
  return result;
}
