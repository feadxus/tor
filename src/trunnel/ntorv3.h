/* ntorv3.h -- generated by Trunnel v1.5.3.
 * https://gitweb.torproject.org/trunnel.git
 * You probably shouldn't edit this file.
 */
#ifndef TRUNNEL_NTORV3_H
#define TRUNNEL_NTORV3_H

#include <stdint.h>
#include "trunnel.h"

#define TRUNNEL_EXT_TYPE_SUBPROTO_REQ 3
#if !defined(TRUNNEL_OPAQUE) && !defined(TRUNNEL_OPAQUE_TRN_NTORV3_EXT_SUBPROTO_REQ)
struct trn_ntorv3_ext_subproto_req_st {
  uint8_t proto_id;
  uint8_t proto_version;
  uint8_t trunnel_error_code_;
};
#endif
typedef struct trn_ntorv3_ext_subproto_req_st trn_ntorv3_ext_subproto_req_t;
#if !defined(TRUNNEL_OPAQUE) && !defined(TRUNNEL_OPAQUE_TRN_NTORV3_EXT_SUBPROTO)
struct trn_ntorv3_ext_subproto_st {
  TRUNNEL_DYNARRAY_HEAD(, struct trn_ntorv3_ext_subproto_req_st *) reqs;
  uint8_t trunnel_error_code_;
};
#endif
typedef struct trn_ntorv3_ext_subproto_st trn_ntorv3_ext_subproto_t;
/** Return a newly allocated trn_ntorv3_ext_subproto_req with all
 * elements set to zero.
 */
trn_ntorv3_ext_subproto_req_t *trn_ntorv3_ext_subproto_req_new(void);
/** Release all storage held by the trn_ntorv3_ext_subproto_req in
 * 'victim'. (Do nothing if 'victim' is NULL.)
 */
void trn_ntorv3_ext_subproto_req_free(trn_ntorv3_ext_subproto_req_t *victim);
/** Try to parse a trn_ntorv3_ext_subproto_req from the buffer in
 * 'input', using up to 'len_in' bytes from the input buffer. On
 * success, return the number of bytes consumed and set *output to the
 * newly allocated trn_ntorv3_ext_subproto_req_t. On failure, return
 * -2 if the input appears truncated, and -1 if the input is otherwise
 * invalid.
 */
ssize_t trn_ntorv3_ext_subproto_req_parse(trn_ntorv3_ext_subproto_req_t **output, const uint8_t *input, const size_t len_in);
/** Return the number of bytes we expect to need to encode the
 * trn_ntorv3_ext_subproto_req in 'obj'. On failure, return a negative
 * value. Note that this value may be an overestimate, and can even be
 * an underestimate for certain unencodeable objects.
 */
ssize_t trn_ntorv3_ext_subproto_req_encoded_len(const trn_ntorv3_ext_subproto_req_t *obj);
/** Try to encode the trn_ntorv3_ext_subproto_req from 'input' into
 * the buffer at 'output', using up to 'avail' bytes of the output
 * buffer. On success, return the number of bytes used. On failure,
 * return -2 if the buffer was not long enough, and -1 if the input
 * was invalid.
 */
ssize_t trn_ntorv3_ext_subproto_req_encode(uint8_t *output, size_t avail, const trn_ntorv3_ext_subproto_req_t *input);
/** Check whether the internal state of the
 * trn_ntorv3_ext_subproto_req in 'obj' is consistent. Return NULL if
 * it is, and a short message if it is not.
 */
const char *trn_ntorv3_ext_subproto_req_check(const trn_ntorv3_ext_subproto_req_t *obj);
/** Clear any errors that were set on the object 'obj' by its setter
 * functions. Return true iff errors were cleared.
 */
int trn_ntorv3_ext_subproto_req_clear_errors(trn_ntorv3_ext_subproto_req_t *obj);
/** Return the value of the proto_id field of the
 * trn_ntorv3_ext_subproto_req_t in 'inp'
 */
uint8_t trn_ntorv3_ext_subproto_req_get_proto_id(const trn_ntorv3_ext_subproto_req_t *inp);
/** Set the value of the proto_id field of the
 * trn_ntorv3_ext_subproto_req_t in 'inp' to 'val'. Return 0 on
 * success; return -1 and set the error code on 'inp' on failure.
 */
int trn_ntorv3_ext_subproto_req_set_proto_id(trn_ntorv3_ext_subproto_req_t *inp, uint8_t val);
/** Return the value of the proto_version field of the
 * trn_ntorv3_ext_subproto_req_t in 'inp'
 */
uint8_t trn_ntorv3_ext_subproto_req_get_proto_version(const trn_ntorv3_ext_subproto_req_t *inp);
/** Set the value of the proto_version field of the
 * trn_ntorv3_ext_subproto_req_t in 'inp' to 'val'. Return 0 on
 * success; return -1 and set the error code on 'inp' on failure.
 */
int trn_ntorv3_ext_subproto_req_set_proto_version(trn_ntorv3_ext_subproto_req_t *inp, uint8_t val);
/** Return a newly allocated trn_ntorv3_ext_subproto with all elements
 * set to zero.
 */
trn_ntorv3_ext_subproto_t *trn_ntorv3_ext_subproto_new(void);
/** Release all storage held by the trn_ntorv3_ext_subproto in
 * 'victim'. (Do nothing if 'victim' is NULL.)
 */
void trn_ntorv3_ext_subproto_free(trn_ntorv3_ext_subproto_t *victim);
/** Try to parse a trn_ntorv3_ext_subproto from the buffer in 'input',
 * using up to 'len_in' bytes from the input buffer. On success,
 * return the number of bytes consumed and set *output to the newly
 * allocated trn_ntorv3_ext_subproto_t. On failure, return -2 if the
 * input appears truncated, and -1 if the input is otherwise invalid.
 */
ssize_t trn_ntorv3_ext_subproto_parse(trn_ntorv3_ext_subproto_t **output, const uint8_t *input, const size_t len_in);
/** Return the number of bytes we expect to need to encode the
 * trn_ntorv3_ext_subproto in 'obj'. On failure, return a negative
 * value. Note that this value may be an overestimate, and can even be
 * an underestimate for certain unencodeable objects.
 */
ssize_t trn_ntorv3_ext_subproto_encoded_len(const trn_ntorv3_ext_subproto_t *obj);
/** Try to encode the trn_ntorv3_ext_subproto from 'input' into the
 * buffer at 'output', using up to 'avail' bytes of the output buffer.
 * On success, return the number of bytes used. On failure, return -2
 * if the buffer was not long enough, and -1 if the input was invalid.
 */
ssize_t trn_ntorv3_ext_subproto_encode(uint8_t *output, size_t avail, const trn_ntorv3_ext_subproto_t *input);
/** Check whether the internal state of the trn_ntorv3_ext_subproto in
 * 'obj' is consistent. Return NULL if it is, and a short message if
 * it is not.
 */
const char *trn_ntorv3_ext_subproto_check(const trn_ntorv3_ext_subproto_t *obj);
/** Clear any errors that were set on the object 'obj' by its setter
 * functions. Return true iff errors were cleared.
 */
int trn_ntorv3_ext_subproto_clear_errors(trn_ntorv3_ext_subproto_t *obj);
/** Return the length of the dynamic array holding the reqs field of
 * the trn_ntorv3_ext_subproto_t in 'inp'.
 */
size_t trn_ntorv3_ext_subproto_getlen_reqs(const trn_ntorv3_ext_subproto_t *inp);
/** Return the element at position 'idx' of the dynamic array field
 * reqs of the trn_ntorv3_ext_subproto_t in 'inp'.
 */
struct trn_ntorv3_ext_subproto_req_st * trn_ntorv3_ext_subproto_get_reqs(trn_ntorv3_ext_subproto_t *inp, size_t idx);
/** As trn_ntorv3_ext_subproto_get_reqs, but take and return a const
 * pointer
 */
 const struct trn_ntorv3_ext_subproto_req_st * trn_ntorv3_ext_subproto_getconst_reqs(const trn_ntorv3_ext_subproto_t *inp, size_t idx);
/** Change the element at position 'idx' of the dynamic array field
 * reqs of the trn_ntorv3_ext_subproto_t in 'inp', so that it will
 * hold the value 'elt'. Free the previous value, if any.
 */
int trn_ntorv3_ext_subproto_set_reqs(trn_ntorv3_ext_subproto_t *inp, size_t idx, struct trn_ntorv3_ext_subproto_req_st * elt);
/** As trn_ntorv3_ext_subproto_set_reqs, but does not free the
 * previous value.
 */
int trn_ntorv3_ext_subproto_set0_reqs(trn_ntorv3_ext_subproto_t *inp, size_t idx, struct trn_ntorv3_ext_subproto_req_st * elt);
/** Append a new element 'elt' to the dynamic array field reqs of the
 * trn_ntorv3_ext_subproto_t in 'inp'.
 */
int trn_ntorv3_ext_subproto_add_reqs(trn_ntorv3_ext_subproto_t *inp, struct trn_ntorv3_ext_subproto_req_st * elt);
/** Return a pointer to the variable-length array field reqs of 'inp'.
 */
struct trn_ntorv3_ext_subproto_req_st * * trn_ntorv3_ext_subproto_getarray_reqs(trn_ntorv3_ext_subproto_t *inp);
/** As trn_ntorv3_ext_subproto_get_reqs, but take and return a const
 * pointer
 */
const struct trn_ntorv3_ext_subproto_req_st *  const  * trn_ntorv3_ext_subproto_getconstarray_reqs(const trn_ntorv3_ext_subproto_t *inp);
/** Change the length of the variable-length array field reqs of 'inp'
 * to 'newlen'.Fill extra elements with NULL; free removed elements.
 * Return 0 on success; return -1 and set the error code on 'inp' on
 * failure.
 */
int trn_ntorv3_ext_subproto_setlen_reqs(trn_ntorv3_ext_subproto_t *inp, size_t newlen);


#endif
